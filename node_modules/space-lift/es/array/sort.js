import { ArrayOps } from '../lift';
/**
* Sorts the Array. The sort is stable.
* If you want to sort on field "a" then on field "b", just chain a sort on "b" then a sort on "a".
*
* An option Object can be passed to modify the sort behavior.
* The supported options are:
*
* ignoreCase: Assuming strings are going to be sorted, ignore their cases. Defaults to false.
*
* localCompare: Assuming strings are going to be sorted,
*   handle locale-specific characters correctly at the cost of reduced sort speed. Defaults to false.
*
* by: Assuming objects are being sorted, a function either pointing to or computing the value
*   that should be used for the sort. Defaults to undefined.
*
* reverse: Reverses the sort. Defaults to false.
*/
export function sort(options) {
    var arr = this.value();
    var o = options || {};
    var mapped = [];
    var missingData = [];
    var result = [];
    var sortFunction;
    for (var i = 0, length = arr.length; i < length; i++) {
        var item = arr[i];
        var originalItem = item;
        if (o.by && item)
            item = o.by(item);
        if (item === null || item === undefined || item === '') {
            missingData.push(originalItem);
            continue;
        }
        mapped.push({
            index: i,
            value: o.ignoreCase ? item.toUpperCase() : item
        });
    }
    if (o.localeCompare) {
        sortFunction = function (a, b) {
            if (a.value !== b.value)
                return a.value.localeCompare(b.value);
            else
                return a.index < b.index ? -1 : 1;
        };
    }
    else {
        sortFunction = function (a, b) {
            if (a.value !== b.value)
                return a.value < b.value ? -1 : 1;
            else
                return a.index < b.index ? -1 : 1;
        };
    }
    mapped.sort(sortFunction);
    for (var i = 0, length = mapped.length; i < length; i++) {
        result.push(arr[mapped[i].index]);
    }
    if (missingData.length)
        result = result.concat(missingData);
    if (o.reverse)
        result.reverse();
    return new ArrayOps(result);
}
ArrayOps.prototype.sort = sort;
