declare type UnionDescription = Record<string, (...args: any[]) => any>;
declare type UnionResult<T extends UnionDescription> = {
    T: Union<T>;
    is: <NAME extends keyof T>(name: NAME) => <U extends Union<T>>(other: U) => other is (ReturnType<T[NAME]> & {
        type: NAME;
    });
    factories: {
        [K in keyof T]: Factory<T[K], K> & {
            T: ReturnType<Factory<T[K], K>>;
        };
    };
};
declare type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
declare type Factory<F extends (...args: any[]) => any, TYPE> = (...args: Arguments<F>) => F extends (...args: any[]) => infer R ? {
    [K in keyof R | 'type']: K extends 'type' ? TYPE : R[K & keyof R];
} : (...args: any[]) => any;
declare type Union<T extends UnionDescription> = {
    [K in keyof T]: {
        [K2 in keyof ReturnType<T[K]> | 'type']: K2 extends 'type' ? K : ReturnType<T[K]>[K2];
    };
}[keyof T];
declare type Arguments<T extends (...args: any[]) => any> = T extends (...args: infer A) => any ? A : [];
/**
 * Creates a type-safe union, providing: derived types, factories and type-guards in a single declaration.
 */
export declare function createUnion<D extends UnionDescription>(description: D): UnionResult<D>;
export declare function empty(): {};
export {};
