//--------------------------------------
//  Shallow update
//--------------------------------------
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
export function update(host, spec) {
    var result = cloneObject(host);
    var hasChanged = false;
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === DELETE) {
            delete result[key];
            hasChanged = hasChanged || key in host;
        }
        else {
            result[key] = specValue;
            hasChanged = hasChanged || host[key] !== specValue;
        }
    }
    return hasChanged ? result : host;
}
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
export var DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        return this.modify(function (_) { return value; });
    };
    _Updater.prototype.modify = function (modifier) {
        var target = this.findTarget();
        var result = this.cloneForUpdate(target);
        if (result.name === 'aborted')
            return target;
        var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field, structurallyModified = result.structurallyModified;
        var leafHostIsOption = isOptionLike(leafHost);
        var currentValue = leafHostIsOption ? leafHost.get() : leafHost[field];
        var value = modifier(currentValue);
        // Actually shallow update, e.g deepUpdate(obj).set(otherObj)
        // Not much point but the typings make it possible ¯\_(ツ)_/¯
        if (field === '')
            return leafHostIsOption
                ? leafHost.Option(value)
                : value;
        var modified = structurallyModified;
        if (value === DELETE) {
            if (leafHostIsOption) {
                if (field in leafHost.value)
                    modified = true;
                delete leafHost.value[field];
            }
            else {
                if (field in leafHost)
                    modified = true;
                delete leafHost[field];
            }
        }
        else {
            if (currentValue !== value)
                modified = true;
            if (leafHostIsOption) {
                leafHost.value[field] = value;
            }
            else {
                // Setting a T | undefined as the value of an Option
                // should actually build a new Option<T>
                var finalValue = isOptionLike(currentValue)
                    ? currentValue.Option(value)
                    : value;
                leafHost[field] = finalValue;
            }
        }
        return modified ? clonedTarget : target;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: clone(value) });
    };
    _Updater.prototype.abortIfNot = function (predicate) {
        return new _Updater({ type: 'abortIfNot', parent: this, predicate: predicate });
    };
    _Updater.prototype.abortIfUndef = function () {
        return this.abortIfNot(function (value) {
            if (isOptionLike(value))
                return value.type === 'some';
            return value !== undefined;
        });
    };
    _Updater.prototype.findTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.target;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        var hostIsOption = isOptionLike(host);
        var previousHostIsOption = isOptionLike(previousHost);
        if (this.data.type === 'at') {
            var newField = this.data.field;
            if (hostIsOption) {
                if (host.type === 'none')
                    return { host: undefined, field: newField };
                host.value = clone(host.value);
                var value = host.value[newField];
                var nextValue = clone(value);
                var newHost_1 = isLast ? host : nextValue;
                host.value[this.data.field] = nextValue;
                return { host: newHost_1, field: newField };
            }
            else {
                if (!host)
                    return { host: undefined, field: newField };
                var value = host[newField];
                var nextValue = clone(value);
                var newHost_2 = isLast ? host : nextValue;
                host[this.data.field] = nextValue;
                return { host: newHost_2, field: newField };
            }
        }
        if (this.data.type === 'abortIfNot' && this.data.predicate(host) === false) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && (previousHost[field] === undefined || isOptionLike(previousHost[field]))) {
            var nextValue = isOptionLike(host)
                ? host.Option(this.data.defaultValue)
                : this.data.defaultValue;
            var newHost_3 = isLast
                ? previousHost
                : nextValue;
            if (previousHostIsOption)
                previousHost.value[field] = nextValue;
            else
                previousHost[field] = nextValue;
            return { host: newHost_3, field: field, structurallyModified: true };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = cloneContainer(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        var structurallyModified = false;
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            structurallyModified = structurallyModified || result.structurallyModified;
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field,
            structurallyModified: structurallyModified
        };
    };
    return _Updater;
}());
// TODO: This probably won't fly with some weird edge cases like deepUpdate(new Date()).set(), etc
// For completion sake, we should probably fix it.
function isContainer(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    return isContainer(obj) ? cloneContainer(obj) : obj;
}
function cloneContainer(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    if (isOptionLike(obj))
        return obj.map(identity);
    return cloneObject(obj);
}
function cloneObject(obj) {
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function identity(x) {
    return x;
}
function isOptionLike(obj) {
    return !!obj && (obj.type === 'some' || obj.type === 'none') && obj.Option;
}
export function deepUpdate(target) {
    return new _Updater({ type: 'root', target: target });
}
